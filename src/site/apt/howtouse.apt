            ------
            基本的な使い方
            ------
            Tatsuo TSUCHIE
            ------
            2014-11-28

基本的な使い方

%{toc|section=1|fromDepth=1|toDepth=3}

* {はじめに}
 
 このライブラリは、CSV用ライブラリ'{{{SuperCSV}http://supercsv.sourceforge.net/}}'に、アノテーション機能を追加したものです。
 
 主な機能は、次の通りです。
 
 * JavaBeanに付与したアノテーションを元に、「CellProcessor」を自動的に組み立てます。
 
 * 読み込み時のエラーをフォーマットしたメッセージとして出力できます。
 
 []

** {前提環境}

 * SuperCSV 2.x
 
   * 旧バージョンの Super CSV ver1.5を仕様する場合、{{{Super CSV Annotation for 2.x}https://mygreen.github.io/super-csv-annotation1}}を利用してください。
   
 * JDK1.6+
  
   * SuperCSV 2.xはJDK1.5以上に対応していますが、本ライブラリはJava1.6以上のみ対応しています。
   
 []

* {基本}

** {CSV用のJavaBeanの定義}

 * クラスには、アノテーション「@CsvBean」を付与します。
 
 * カラムに該当するフィールドには、アノテーション「@CsvColumn」を付与します。
 
   * 属性「position」で、カラムの位置を0から順番に定義します。
   
 * フィールに対するアクセッサーメソッドのgetter/setterは必ず定義してください。
 
   * SuperCSV自体がアクセッサーメソッドが必須のめ、定義していないと例外が発生します。
   
 * boolean型のgetterについては、名称は'get～'としてください。
 
   * 'is～'の場合、SuperCSV自体が対応していないためです。
   
   * ただし、SuperCSV2.xから、isメソッドも対応しています。
   
 []

------
// Java Bean
@CsvBean(header=true)
public class UserCsv{
    
    @CsvColumn(position = 0)
    private int id;
    
    @CsvColumn(position = 1)
    private String name;
    
    @CsvColumn(position = 2, optional=true)
    private int age;
    
    @CsvDateConverter(pattern="yyyy-MM-dd")
    @CsvColumn(position = 3, optional=true)
    public Date birthday;
    
    // setter/getterは省略
}
------

** {読み込み方}

 CsvAnnotationBeanParserを利用し、CSV用のBeanクラスをパースし、CsvBeanMappingのインスタンスを作成します。
 
 CsvBeanMapping#getInputCellProcessor()で、読み込み用のCellProcessorの配列を取得できます。
 
 取得したCellProceesorの配列を、既存のCsvBeanReaderに渡すことで、読み込みが可能です。
 
--------
// create cell processor and field name mapping 
CsvAnnotationBeanParser helper = new CsvAnnotationBeanParser();
CsvBeanMapping<SampleBean1> mappingBean = helper.parse(SampleBean1.class, false);
 
CellProcessor[] cellProcessors = mappingBean.getInputCellProcessor();
 
File inputFile = new File("src/test/data/test_error.csv");
ICsvBeanReader csvReader = new CsvBeanReader(
   new InputStreamReader(new FileInputStream(inputFile), "Windows-31j"),
       CsvPreference.STANDARD_PREFERENCE);
 
// raed bean data. 
List<SampleBean1> list = new ArrayList<SampleBean1>();
String[] headers = csvReader.getHeader(true);
while((bean1 = csvReader.read(SampleBean1.class, nameMapping, cellProcessors)) != null) {
    System.out.println(bean1);
    list.add(bean1);
}
--------

 本ライブラリのCsvAnnotationBeanReaderクラスを利用すると、簡単に読み込めます。
 
--------
File inputFile = new File("src/test/data/test_error.csv");
CsvAnnotationBeanReader csvReader = 
    new CsvAnnotationBeanReader(SampleBean1.class, strWriter, CsvPreference.STANDARD_PREFERENCE);
 
// read bean data. 
List<SampleBean1> list = new ArrayList<SampleBean1>();
String[] headers = csvReader.getHeader();  // use custom method. 
while((bean1 = csvReader.read()) != null) {
    System.out.println(bean1);
    list.add(bean1);
}
--------

** {書き込み方}

 CsvAnnotationBeanParserを利用し、CSV用のBeanクラスをパースし、CsvBeanMappingのインスタンスを作成します。
 
 CsvBeanMapping#getNameMapping()で、見出し行の配列を取得できます。
 
 CsvBeanMapping#getOutputCellProcessor()で、書き込み用のCellProcessorの配列を取得できます。
 
 取得した見出し行の配列やCellProceesorの配列を、既存のCsvBeanReaderに渡すことで、書き込みが可能です。


--------
// create cell processor and field name mapping 
CsvAnnotationBeanParser helper = new CsvAnnotationBeanParser();
CsvBeanMapping<SampleBean1> mappingBean = helper.parse(SampleBean1.class, false);
 
String[] nameMapping = mappingBean.getNameMapping();
CellProcessor[] cellProcessors = mappingBean.getOutputCellProcessor();
 
StringWriter strWriter = new StringWriter();
ICsvBeanWriter csvWriter = null;
csvWriter = new CsvBeanWriter(strWriter, CsvPreference.STANDARD_PREFERENCE);
 
// write bean data. 
List<SampleBean1> list = ...;
csvWriter.writeHeader(mappingBean.getHeader());
for(final SampleBean1 item : list) {
    csvWriter.write(item, nameMapping, cellProcessors);
    csvWriter.flush();
}
--------

 本ライブラリのCsvAnnotationBeanWriterクラスを利用すると、簡単に書き込めます。
 
--------
StringWriter strWriter = new StringWriter();
CsvAnnotationBeanWriter<SampleBean1> csvWriter = 
    new CsvAnnotationBeanWriter<SampleBean1>(SampleBean1.class, 
        strWriter, CsvPreference.STANDARD_PREFERENCE);
 
// write bean data. 
List<SampleBean1> list = ...;
csvWriter.writeHeader();  // use custom method. 
for(final SampleBean1 item : list) {
    csvWriter.write(item);  // use cutom method. 
    csvWriter.flush();
}
--------

* {基本的なアノテーションの仕様}

** {@CsvEntity}

 JavaBeanのクラスに「@CsvEntity」を付与することで、CSV用のJavaBeanとして定義します。

 * 属性「header」の値により、読み込み時、書き込み時に見出し行を処理します。
 
  * CsvAnnotationBeanReader#readHeader(...) / CsvAnnotationBeanWriter#writeHeader()メソッド呼び出し時に、
    設定値によって見出し行の処理が変わります。
 
------
@CsvBean(header=true)
public class SampleBean1{
...
}
------

** {@CsvColumn}

 CSVのカラムとして扱うフィールドに付与します。
 付与するフィールドの修飾子は、public / private / protected のどれでもかまいません。
 
 * 属性「position」は、カラムのインデックス位置を指定します。0から順に指定します。
 
   * 途中でインデックス番号が飛んでいたり、重複している場合は、エラーが発生します。
 
 * 属性「label」で、カラムの見出しを指定します。指定しない場合は、フィールド名がデフォルト値となります。
 
 * 属性「optional」で、そのカラムの値がnullまたは、空文字を許すかどうか指定します。
 
   * trueを指定した場合、CellProcessorの「Optional」が設定されます。
   
   * falseを指定した場合は、CellProcessorの「NotNull」が設定されます。
   
   * 初期値は、falseで、nullまたは空文字を許可しません。
   
 * 属性「trim」で、読み込み時または書き込み時にカラムの値をトリムするか指定します。
 
   * trueを指定した場合、CellProcessorの「Trim」が設定されます。
   
   * 初期値はfalseです。
   
 * 属性「inputDefaultValue」で、読み込み時のカラムの値がnullまたは空文字のときのデフォルト値を指定します。
 
   * 日付型などの書式を伴うカラムの場合は、書式に合わせた値を設定してください。
  
   * 文字列型のときに、空文字として扱いたい場合は、属性「optional=true」を指定します。
 
 * 属性「outputDefaultValue」で、書き込み時のカラムの値がnullまたは空文字のときのデフォルト値を指定します。
 
   * 日付型などの書式を伴うカラムの場合は、書式に合わせた値を設定してください。
  
   * 文字列型のときに、空文字として扱いたい場合は、属性「optional=true」を指定します。
   
 * 属性「unique」は、読み込み時／書き込み時に、カラムの値がユニークかどうかチェックします。
 
   * trueを指定した場合、CellProcessorの「Unique」が設定されます。
   
 * 属性「equalsValue」は、読み込み時／書き込み時に、カラムの値が指定した値と等しいかチェックします。
 
   * 値を指定した場合、CellProcessorの「Equals」が設定されます。
 
 * 属性「builderClass」で、自分で作成したCellProcessorBuilderを指定できます。
 
   * 独自のCellProcessorを使用するときに指定します。
 
 []

------
// Java Bean
@CsvBean(header=true)
public class SampleBean1{
    
    @CsvColumn(position = 0, optional = true)
    private int integer1;
    
    @CsvColumn(position = 1, optional = false, unique = true)
    private Integer integer2;
    
    @CsvColumn(position = 2, optional = true, trim = true, inputDefaultValue="aa")
    public String string3;
    
    @CsvDateConverter(pattern="yyyy-MM-dd HH:mm:ss")
    @CsvColumn(position = 3, inputDefaultValue="2012-10-13 00:00:00")
    public Date date4;
    
    @CsvColumn(position = 4, outputValue="false")
    public boolean boole5;
    
    @CsvColumn(position = 5, inputDefaultValue="RED", outputDefaultValue="BLUE")
    public Color enum6;
    
    enum Color {
       RED, BLUE, GREEN, YELLOW;
    }
}
------

 上記の例では、CellProcessorは次のように組み立てられます。

 * フィールド「integer1」に対するCellProcessorは次のように組み立てられます。
 
------
  // annotation set for 
  @CsvColumn(position = 0, optional = true)
  private int integer1;
  
  // build CellProcessor for reading
  new Optional(new ParseInt())
  
  // build CellProcessor for writing
  new Optional()
------
 
 * フィールド「integer2」に対するCellProcessorは次のように組み立てられます。

------
  // annotation set for 
  @CsvColumn(position = 1, optional = false, unique = true)
  private Integer integer2;
  
  // build CellProcessor for reading
  new NotNull(new Unique(new ParseInt()))
 
  // build CellProcessor for writing
  new NotNull(new Unique())
------

 * フィールド「string3」に対するCellProcessorは次のように組み立てられます。

------
  // annotation set for 
  @CsvColumn(position = 2, optional = true, trim = true, inputDefaultValue="aa")
  public String string3;
  
  // build CellProcessor for reading
  new ConvertNullTo("aa", new Optional(new Trim()))
 
  // build CellProcessor for writing
  new Optional(new Trim())
------

 * フィールド「date4」に対するCellProcessorは次のように組み立てられます。
 
------
  // annotation set for 
  @CsvDateConverter(pattern="yyyy-MM-dd HH:mm:ss")
  @CsvColumn(position = 3, defaultValue="2012-10-13 00:00:00")
  public Date date4;
      
  // build CellProcessor for reading
  // use format pattern 'yyyy-MM-dd HH:mm:ss'
  new NotNull(new ParseLocaleDate("yyyy-MM-dd HH:mm:ss"))
 
  // build CellProcessor for writing
  // use format pattern 'yyyy-MM-dd HH:mm:ss'
  new NotNull(ConvertNullTo( /* date obj("2012-10-13 00:00:00") */, new FormatLocaleDate("yyyy-MM-dd HH:mm:ss")))
------

 * フィールド「bool5」に対するCellProcessorは次のように組み立てられます。
 
------
  // annotation set for 
  @CsvColumn(position = 4, inputDefaultValue="false")
  public boolean boole5;
  
  // build CellProcessor for reading
  new ConvertNullTo( /*boolean obj('false')*/, new NotNull( new ParseBoolean()))
 
  // build CellProcessor for writing
  new NotNull( new FmtBool())
------

 * フィールド「enum6」に対するCellProcessorは次のように組み立てられます。
 
------
  // annotation set for 
  @CsvColumn(position = 5, inputDefaultValue="RED", outputDefaultValue="BLUE")
  public Color enum6;
  
  // build CellProcessor for reading
  new ConvertNullTo(/*enum obj('RED')*/, new NotNull(new ParseEnum()))
  
  // build CellProcessor for writing
  new ConvertNullTo("BLUE", new NotNull( new FormatEnum()))
------

 []


* {型変換用のアノテーションの仕様}

** {@CsvStringConverter}

 @CsvStrngConverterは、文字列型に対する変換や制約を指定するアノテーションです。
 
 String、char/Charcter 型に付与可能です。

-------------
@CsvBean
public class User {

  @CsvColumn(position=0)
  @CsvStringConverter(maxLength=100, notEmpty=true)
  private String name;

}
-------------

 * 属性「minLength」は、最小文字長のチェックを行いたい場合に指定します。
 
   * 値を指定した場合、CellProcessorの「MinLength」が設定されます。
 
 * 属性「maxLength」は、最大文字長のチェックを行いたい場合に指定します。
 
   * 値を指定した場合、CellProcessorの「MaxLength」が設定されます。
   
   * 属性「minLength」と「maxLength」が両方指定された場合、CellProcessorの「StrMinMax」が設定されます。
 
 * 属性「exactLength」は、指定した長さの文字長かどうかチェックを行いたい場合に指定します。
 
   * 値を指定した場合は、CellProcessorrの「Strlen」が設定されます。
   
 * 属性「regex」は、正規表現のパターンに一致するかチェックを行いたい場合に指定します。
 
   * 値を指定した場合は、CellProcessorの「StrRegEx」が設定されます。
 
 * 属性「fobid」は、指定した語彙を含んでいないかどうか、禁止語彙のチェックを行いたい場合に指定します。
  
   * 値を指定した場合は、CellProcessorの「ForbitSubStr」が設定されます。
   
 * 属性「contain」は、指定した語彙を含んでいるかどうかチェックを行いたい場合に指定します。
 
   * 値を指定した場合は、CellProcessorの「RequireSubStr」が設定されます。
   
 * 属性「notEmpty」は、空文字でないかチェックしたい場合に指定します。
 
   * 'true'を指定した場合は、CellProcessorの「StrNotNullOrEmpty」が設定されます。
   
   * @CsvColumnの属性「optional」を'false'にしていた場合、CellProcessor「NotNull」が設定されるため、この値の意味がなくなります。
 
 []
 

** {@CsvNumberConverter}

 @CsvNumberConverterは、数値型に対して書式を指定した変換や制約を指定するアノテーションです。

 byte / shortint / long / float / double / Byte / Integer / Long / Float / Double / BigDecimal / BigInteger 型に付与可能です。

-------------
@CsvBean
public class Data {

  @CsvColumn(position=0)
  @CsvNumberConverter(pattern="##.##", min="0.0")
  private double average;

}
-------------


 * 属性「pattern」は、書式を指定したい場合に指定します。
 
   * 値を指定した場合、このライブラリ独自のCellProcessor「FormatLocaleNumber」が設定されます。
   
   * 値を指定しない場合は、Integer.parseInt(...)などで読み込み時に処理されます。
   
 * 属性「lenient」は、読み込み時に正確に値をパースするかを指定します。
 
   * 'true'を指定した場合、BigDecimal#intValueExact(...)を使って正確に値を読み取ります。
   
   * 'false'を指定した場合、BigDecimal#intValue(...)を使って読み取ります。
 
 * 属性「locale」は、pattern属性で書式を指定して読み込む際の、ロケールを指定する際に使用します。
 
   * 'ja'、'ja_JP'などように指定します。
 
 * 属性「min」は、指定した値以上かどうかのチェックを行いたい場合に指定します。
 
   * 値を指定した場合は、このライブラリ独自のCellProcessor「Min」が設定されます。
   
   * 属性patternで書式を指定する場合は、その書式に沿った形式で指定します。
   
 * 属性「max」は、指定した値以下かどうかのチェックを行いたい場合に指定します。
 
   * 値を指定した場合は、このライブラリ独自のCellProcessor「Max」が設定されます。
   
   * 属性patternで書式を指定する場合は、その書式に沿った形式で指定します。
   
   * 属性「min」と「max」の両方が指定された場合は、このライブラリ独自のCellProcessor「Range」が設定されます。

 []

** {@CsvDateConverter}

 @CsvDateConverterは、日時型に対して書式を指定した変換や制約を指定するアノテーションです。
 
  java.util.Date / java.sql.Date / java.sql.Time / java.sql.Timestamp 型に付与可能です。

-------------
@CsvBean
public class User {

  @CsvColumn(position=0)
  @CsvDatarConverter(pattern="yyy年MM月dd日", locale="ja_JP", lenient=true)
  private Date birthday;

}
-------------

 * 属性「pattern」は、書式を指定したい場合に指定します。
 
   * 値を指定した場合、このライブラリ独自のCellProcessor「LocaleLocaleDate」が設定されます。
   
   * 値を指定しない場合は、'yyyy-MM-dd HH:mm:ss'が指定されます。
 
 * 属性「lenient」は、読み込み時に正確に値をパースするかを指定します。
 
   * 'true'を指定した場合、SimpelDateFormat#setLenient(true)が設定され処理されます。
   
   * 'false'を指定した場合、SimpelDateFormat#setLenient(fales)が設定され処理されます。
 
 * 属性「timezone」は、タイムゾーンを指定したい場合に指定します。
 
  * 形式は、TimeZone#getTimeZone(...)で処理可能な、"Asia/Tokyo"などで指定します。
 
 * 属性「locale」は、pattern属性で書式を指定して読み込む際の、ロケールを指定する際に使用します。
 
   * 'ja'、'ja_JP'などように指定します。
 
 * 属性「min」は、指定した時間以降かどうかのチェックを行いたい場合に指定します。
 
   * 値を指定した場合は、このライブラリ独自のCellProcessor「FutureDate」が設定されます。
   
   * 属性patternで書式を指定する場合は、その書式に沿った形式で指定します。
   
 * 属性「max」は、指定した時間以前かどうかのチェックを行いたい場合に指定します。
 
   * 値を指定した場合は、このライブラリ独自のCellProcessor「PastDate」が設定されます。
   
   * 属性patternで書式を指定する場合は、その書式に沿った形式で指定します。
  
   * 属性「min」と「max」の両方が指定された場合は、このライブラリ独自のCellProcessor「DateRange」が設定されます。

 []

** {@CsvBooleanConverter}

 @CsvBooleanConverterは、ブール型に対して書式を指定した変換や制約を指定するアノテーションです。

 boolean / Boolean 型に付与可能です。

-------------
@CsvBean
public class Data {

  @CsvColumn(position=0)
  @CsvBooleanConverter(inputTrueValues={"○"}, inputFalseValues={"×", "-"}, outputTrueValue="○", outputFalseValue="×")
  private boolean completed;

}
-------------
 
 * 属性「inputTrueValues」で、読み込み時に'true'として読み込む値の候補を配列で指定します。
 
   * デフォルト値として\{"true", "1", "yes", "on", "y", "t"\}が指定されてます。
   
   * 処理する際には、本ライブラリの独自のCellProcessor「ParseBoolean」が設定されます。
   
 * 属性「inputFalseValues」で、読み込み時に'false'として読み込む値の候補を配列で指定します。
 
   * デフォルト値として\{"false", "0", "no", "off", "f", "n"\}が指定されてます。
   
   * 処理する際には、本ライブラリの独自のCellProcessor「ParseBoolean」が設定されます。
   
   * 属性「inputTrueValues」と重複した値をしていた場合、処理としてinputTrueValuesの値が優先されます。
   
 * 属性「outputTrueValue」で、書き込み時に'true'として出力する値を指定します。
 
   * デフォルト値として、'true'が設定されています。
   
   * 処理する際には、CellProcessor「FmtBoolean」が設定されます。
   
 * 属性「outputFalseValue」で、書き込み時に'false'として出力する値を指定します。
 
   * デフォルト値として、'false'が設定されています。
   
   * 処理する際には、CellProcessor「FmtBoolean」が設定されます。
 
 * 属性「lenient」は、読み込み時に大文字・小文字を無視するかを指定します。
 
   * デフォルト値は'false'で、大文字・小文字は無視しません。
   
 * 属性「failToFalse」は、読み込み時に変換に失敗した場合に、'false'値として処理するかどうかを指定します。
 
   * 変換に失敗するときの例として、属性「inputTrueValues」「inputFalseValues」の値に一致しないときが該当します。
   
   * 変換に失敗した場合、SuperCsvCellProcessorExceptionがスローされます。

 []
 

** {@CsvEnumConverter }

 @CsvEnumConverterは、列挙型に対して書式を指定した変換や制約を指定するアノテーションです。

-------------
@CsvBean
public class User {

  @CsvColumn(position=0)
  @CsvEnumConverter(ignoreCase=true, valueMethodName="localeName")
  private RoleType role;

}

// 列挙型の定義
public enum Color {
  NorRmal("一般権限"), Admin("管理者権限");
  
  // 別名の設定
  private String localeName;
  
  private RoleType(String localeName) {
    this.localeName = localeName;
  }
  
  // 別名の取得
  public String localeName() {
    return this.localeName;
  }
  
}
-------------

 * 属性「lenient」は、読み込み時に大文字・小文字を無視するかを指定します。
 
   * デフォルト値は'false'で、大文字・小文字は無視しません。
   
 * 属性「valueMethodName」は、列挙型の項目の値を取得するメソッド名を指定します。

   * 指定しない場合、Enum#name()のメソッドの値が使用されます。
 
 []
 
